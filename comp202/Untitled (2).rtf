{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red127\green0\blue85;\red0\green0\blue192;\red106\green62\blue62;
\red63\green127\blue95;\red42\green0\blue255;}
{\*\expandedcolortbl;;\csgenericrgb\c49804\c0\c33333;\csgenericrgb\c0\c0\c75294;\csgenericrgb\c41569\c24314\c24314;
\csgenericrgb\c24706\c49804\c37255;\csgenericrgb\c16471\c0\c100000;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs22 \cf2 import\cf0  java.util.LinkedList;\
\
\cf2 public\cf0  \cf2 class\cf0  BinTree<Key \cf2 extends\cf0  Comparable <Key>, Value> \{\
	Node \cf3 root\cf0 ;\
\
	\cf2 private\cf0  \cf2 class\cf0  Node \{\
		Key \cf3 k\cf0 ;\
		Value \cf3 v\cf0 ;\
		Node \cf3 leftChild\cf0 ;\
		Node \cf3 rightChild\cf0 ;\
		Node \cf3 parent\cf0 ;\
\
		Node(Key \cf4 key\cf0 , Value \cf4 value\cf0 , Node \cf4 parentNode\cf0 )\
		\{\
			\cf5 //Fill yourself\cf0 \
			\cf3 k\cf0  = \cf4 key\cf0 ;\
			\cf3 parent\cf0  = \cf4 parentNode\cf0 ;\
			\cf3 v\cf0  = \cf4 value\cf0 ;\
			\cf3 leftChild\cf0  = \cf2 null\cf0 ;\
			\cf3 rightChild\cf0  = \cf2 null\cf0 ;\
		\}\
		\cf2 public\cf0  Node getleftChild() \{\
			\cf2 return\cf0  \cf3 leftChild\cf0 ;\
		\}\
\
		\cf2 public\cf0  Node getrightChild() \{\
			\cf2 return\cf0  \cf3 rightChild\cf0 ;\
		\}\
\
		\cf2 public\cf0  Node \ul getParent()\ulnone  \{\
			\cf2 return\cf0  \cf3 parent\cf0 ;\
		\}\
\
	\}\
\
	\cf5 // Insert a value with the given key\cf0 \
	\cf2 public\cf0  \cf2 void\cf0  put(Key \cf4 key\cf0 , Value \cf4 value\cf0 )\
	\{\
		\cf5 //Fill yourself\cf0 \
		\cf2 if\cf0 (\cf3 root\cf0  == \cf2 null\cf0 ) \{\
			\cf3 root\cf0  = \cf2 new\cf0  Node(\cf4 key\cf0 , \cf4 value\cf0 , \cf2 null\cf0 );\
		\}  \
		\cf2 else\cf0  \{\
			Node \cf4 parentNode\cf0  = getParentNode(\cf4 key\cf0 ); \cf5 \
\pard\pardeftab720\partightenfactor0
\cf0 			Node \cf4 newNode\cf0  = \cf2 new\cf0  Node(\cf4 key\cf0 , \cf4 value\cf0 , \cf4 parentNode\cf0 );\
			\
			\cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 parentNode\cf0 .\cf3 k\cf0 ) < 0) \{\
				\cf4 parentNode\cf0 .\cf3 leftChild\cf0  = \cf4 newNode\cf0 ;\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 parentNode\cf0 .\cf3 k\cf0 ) > 0) \{\
				\cf4 parentNode\cf0 .\cf3 rightChild\cf0  = \cf4 newNode\cf0 ;\
			\} \cf2 else\cf0  \{\
				\cf2 throw\cf0  \cf2 new\cf0  IllegalArgumentException(\cf6 "Key already exists"\cf0 );\
			\}\
		\}\
	\}\
\
	\cf2 public\cf0  Node getParentNode(Key \cf4 key\cf0 ) \{\
		Node \cf4 currentNode\cf0  = \cf3 root\cf0 ;\
		\cf2 while\cf0 (\cf2 true\cf0 ) \{\
			\cf2 if\cf0 (\cf4 currentNode\cf0  == \cf2 null\cf0 ) \{\
				\cf2 break\cf0 ;\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 currentNode\cf0 .\cf3 k\cf0 ) < 0 && \cf4 currentNode\cf0 .\cf3 leftChild\cf0  != \cf2 null\cf0 ) \{\
				\cf4 currentNode\cf0  = \cf4 currentNode\cf0 .getleftChild();\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 currentNode\cf0 .\cf3 k\cf0 ) > 0 && \cf4 currentNode\cf0 .\cf3 rightChild\cf0  != \cf2 null\cf0 ) \{\
				\cf4 currentNode\cf0  = \cf4 currentNode\cf0 .getrightChild();\
			\} \cf2 else\cf0  \{\
				\cf2 break\cf0 ;\
			\}\
		\}\
		\cf2 return\cf0  \cf4 currentNode\cf0 ;\
	\}\
\
	\cf5 //Get the value of the given key or return null if no such key exists\cf0 \
	\cf2 public\cf0  Value get(Key \cf4 key\cf0 )\
	\{\
		\cf5 //Fill yourself\cf0 \
		Node \cf4 currentNode\cf0  = \cf3 root\cf0 ;\
		Value \cf4 result\cf0  = \cf2 null\cf0 ;\
		\cf2 while\cf0 (\cf2 true\cf0 ) \{\
			\cf2 if\cf0 (\cf4 currentNode\cf0  == \cf2 null\cf0 ) \{\
				\cf2 break\cf0 ;\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 currentNode\cf0 .\cf3 k\cf0 ) < 0) \{\
				\cf4 currentNode\cf0  = \cf4 currentNode\cf0 .getleftChild();\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 currentNode\cf0 .\cf3 k\cf0 ) > 0) \{\
				\cf4 currentNode\cf0  = \cf4 currentNode\cf0 .getrightChild();\
			\} \cf2 else\cf0  \{\
				\cf4 result\cf0  = \cf4 currentNode\cf0 .\cf3 v\cf0 ;\
				\cf2 break\cf0 ;\
			\}\
		\}\
		\cf2 return\cf0  \cf4 result\cf0 ;\
\
	\}\
\
	\cf5 //Update the value of given key and return the previous key\cf0 \
	\cf2 public\cf0  Value update(Key \cf4 key\cf0 , Value \cf4 value\cf0 )\
	\{\
		Node \cf4 currentNode\cf0  = \cf3 root\cf0 ;\
		Value \cf4 prev\cf0  = \cf2 null\cf0 ;\
		\cf2 while\cf0 (\cf2 true\cf0 ) \{\
			\cf2 if\cf0 (\cf4 currentNode\cf0  == \cf2 null\cf0 ) \{\
				\cf2 break\cf0 ;\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 currentNode\cf0 .\cf3 k\cf0 ) < 0) \{\
				\cf4 currentNode\cf0  = \cf4 currentNode\cf0 .getleftChild();\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 currentNode\cf0 .\cf3 k\cf0 ) > 0) \{\
				\cf4 currentNode\cf0  = \cf4 currentNode\cf0 .getrightChild();\
			\} \cf2 else\cf0  \{\
				\cf4 prev\cf0  = \cf4 currentNode\cf0 .\cf3 v\cf0 ;\
				\cf4 currentNode\cf0 .\cf3 v\cf0  = \cf4 value\cf0 ;\
				\cf2 break\cf0 ;\
			\}\
		\}\
		\cf2 return\cf0  \cf4 prev\cf0 ;\
\
\
	\}\
\
	\cf5 //Return the values along the path (represented by a linked list) to get to the given key. If no such key is found, still return the path you have followed.\cf0 \
	\cf2 public\cf0  LinkedList<Value> getPath(Key \cf4 key\cf0 )\
	\{\
		\cf5 //Fill yourself\cf0 \
		Node \cf4 currentNode\cf0  = \cf3 root\cf0 ;\
		LinkedList<Value> \cf4 result\cf0  = \cf2 new\cf0  LinkedList<Value>();\
		\cf2 while\cf0 (\cf2 true\cf0 ) \{\
			\cf2 if\cf0 (\cf4 currentNode\cf0  == \cf2 null\cf0 ) \{\
				\cf2 break\cf0 ;\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 currentNode\cf0 .\cf3 k\cf0 ) < 0) \{\
				\cf4 result\cf0 .add(\cf4 currentNode\cf0 .\cf3 v\cf0 );\
				\cf4 currentNode\cf0  = \cf4 currentNode\cf0 .getleftChild();\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 currentNode\cf0 .\cf3 k\cf0 ) > 0) \{\
				\cf4 result\cf0 .add(\cf4 currentNode\cf0 .\cf3 v\cf0 );\
				\cf4 currentNode\cf0  = \cf4 currentNode\cf0 .getrightChild();\
			\} \cf2 else\cf0  \{\
				\cf4 result\cf0 .add(\cf4 currentNode\cf0 .\cf3 v\cf0 );\
				\cf2 break\cf0 ;\
			\}\
		\}\
		\cf2 return\cf0  \cf4 result\cf0 ;\
	\}\
\
	\cf5 //Overwrite all the values of the visited nodes to get to key, including the node with the given key\cf0 \
	\cf2 public\cf0  \cf2 void\cf0  overwritePath(Key \cf4 key\cf0 , Value \cf4 fillValue\cf0 )\
	\{\
		\cf5 //Fill yourself\cf0 \
		Node \cf4 currentNode\cf0  = \cf3 root\cf0 ;\
		\cf2 while\cf0 (\cf2 true\cf0 ) \{\
			\cf2 if\cf0 (\cf4 currentNode\cf0  == \cf2 null\cf0 ) \{\
				\cf2 break\cf0 ;\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 currentNode\cf0 .\cf3 k\cf0 ) < 0 && \cf4 currentNode\cf0 .\cf3 leftChild\cf0  != \cf2 null\cf0 ) \{\
				\cf4 currentNode\cf0 .\cf3 v\cf0  = \cf4 fillValue\cf0 ;\
				\cf4 currentNode\cf0  = \cf4 currentNode\cf0 .getleftChild();\
			\} \cf2 else\cf0  \cf2 if\cf0 (\cf4 key\cf0 .compareTo(\cf4 currentNode\cf0 .\cf3 k\cf0 ) > 0 && \cf4 currentNode\cf0 .\cf3 rightChild\cf0  != \cf2 null\cf0 ) \{\
				\cf4 currentNode\cf0 .\cf3 v\cf0  = \cf4 fillValue\cf0 ;\
				\cf4 currentNode\cf0  = \cf4 currentNode\cf0 .getrightChild();\
			\} \cf2 else\cf0  \{\
				\cf2 break\cf0 ;\
			\}\
			\cf4 currentNode\cf0 .\cf3 v\cf0  = \cf4 fillValue\cf0 ;\
		\}\
	\}\
\
	\cf5 //Return a string of (key,value) pairs using in-order traversal of the tree. Feel free to put whatever delimiter you want between the pair \cf0 \
	\cf2 public\cf0  String toString()\
	\{\
		\cf2 return\cf0  inOrder(\cf3 root\cf0 , \cf6 ""\cf0 );\
\
	\}\
\
	\cf2 public\cf0  String inOrder (Node \cf4 node\cf0 , String \cf4 s\cf0 )\
	\{\
		\cf2 if\cf0 (\cf4 node\cf0  != \cf2 null\cf0 )\{\
			inOrder(\cf4 node\cf0 .getleftChild(),\cf4 s\cf0 );\
			\cf4 s\cf0  = \cf4 s\cf0  + \cf6 "--"\cf0  + \cf4 node\cf0 .\cf3 k\cf0  + \cf6 " - "\cf0  + \cf4 node\cf0 .\cf3 v\cf0  + \cf6 "-- "\cf0 ;\
			inOrder(\cf4 node\cf0 .getrightChild(),\cf4 s\cf0 ); \
		\}\
		\cf2 return\cf0  \cf4 s\cf0 ;\
	\}\
\}\
}